/* autogenerated by Processing revision 1283 on 2022-06-04 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import uibooster.*;
import uibooster.components.*;
import uibooster.model.*;
import uibooster.model.formelements.*;
import uibooster.model.options.*;
import uibooster.utils.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Chess extends PApplet {








Board board = new Board(100, 100);

Piece pb1 = new Pawn(1,6,false,board);
Piece pb2 = new Pawn(2,6,false,board);
Piece pb3 = new Pawn(3,6,false,board);
Piece pb4 = new Pawn(4,6,false,board);    //black pawn
Piece pb5 = new Pawn(5,6,false,board);
Piece pb6 = new Pawn(6,6,false,board);
Piece pb7 = new Pawn(7,6,false,board);
Piece pb8 = new Pawn(0,6,false,board);

Piece pw1 = new Pawn(1,1,true,board);
Piece pw2 = new Pawn(2,1,true,board);
Piece pw3 = new Pawn(3,1,true,board);
Piece pw4 = new Pawn(4,1,true,board);    //white pawn
Piece pw5 = new Pawn(5,1,true,board);
Piece pw6 = new Pawn(6,1,true,board);
Piece pw7 = new Pawn(7,1,true,board);
Piece pw8 = new Pawn(0,1,true,board);

Piece kw = new King(4,0,true,board);    //kings
Piece kb = new King(4,7,false,board);

Piece qw = new Queen(3,0,true,board);    //queens
Piece qb = new Queen(3,7,false,board);

Piece rb1 = new Rook(0,7,false,board);
Piece rb2 = new Rook(7,7,false,board);
Piece rw1 = new Rook(0,0,true,board);    //rooks
Piece rw2 = new Rook(7,0,true,board);

Piece bb1 = new Bishop(2,7,false,board);
Piece bb2 = new Bishop(5,7,false,board);    //bishops
Piece bw1 = new Bishop(2,0,true,board);
Piece bw2 = new Bishop(5,0,true,board);

Piece kb1 = new Knight(1,7,false,board);
Piece kb2 = new Knight(6,7,false,board);    //knights
Piece kw1 = new Knight(1,0,true,board);
Piece kw2 = new Knight(6,0,true,board);


boolean gameStarted = false;
boolean wTurn = false;

String move;  // input coordinates



 public String whosTurn() {
  if (wTurn)
    return "white";
  return "black";
}

 public void setup() {
  /* size commented out by preprocessor */;
}

 public void draw() {
  background(0xFF5A5A59);
  board.draw();
  drawPieces(board);


  if (gameStarted)
    input();

  background(0xFF5A5A59);
  board.draw();
  drawPieces(board);

  wTurn = !wTurn;
  gameStarted = true;
}

 public void input() {
  move = new UiBooster().showTextInputDialog("enter two coordinates separated by space. \n for example: A2 A3 \n"+whosTurn()+"'s turn");

  if (move.length() ==5 && move.charAt(2)==' ' &&
    move.charAt(0) >= 'A' && move.charAt(0) <= 'H' && move.charAt(3) >= 'A' & move.charAt(3) <= 'H' &&      // input validation
    move.charAt(1) >= '1' && move.charAt(1) <= '8' && move.charAt(4) >= '1' & move.charAt(4) <= '8') {

    int x = PApplet.parseInt(move.charAt(0) - 'A');
    int y = PApplet.parseInt(move.charAt(1) - '1');                                    //giving chess coordinates coresponding matrix coordinates
    int x1 = PApplet.parseInt(move.charAt(3) - 'A');
    int y1 = PApplet.parseInt(move.charAt(4) - '1');

    if (board.taken[x][y] != null) {                                                      //are first coordinates pointing a piece?

      if (board.taken[x][y].col == wTurn) {                           //is player trying to move enemys piece?

        if (board.taken[x][y].canMove(x1, y1)) {                            //is this move valid for particular piece?
          board.taken[x][y].makeMove(x1, y1);
        } else
          input();
      } else {
        new UiBooster().showInfoDialog(whosTurn()+"'s turn now");
        input();
      }
    } else {
      new UiBooster().showInfoDialog("square you are trying to access is empty");
      input();
    }
  } else {
    new UiBooster().showInfoDialog("input is not valid \n please enter chess coordinates separated by space");
    input();
  }
}

public static void drawPieces(Board b) {
  for (int i = 0; i < b.taken.length; i++) {
    for (int j = 0; j < b.taken[0].length; j++) {
      if (b.taken[i][j] != null)
        b.taken[i][j].draw();
    }
  }
}
class Bishop extends Piece{
  int x;
  int y;
  boolean col;               //true == white  false == black
  Board b;
  PImage wBishop = loadImage("https://upload.wikimedia.org/wikipedia/commons/9/9b/Chess_blt60.png","png");
  PImage bBishop = loadImage("https://upload.wikimedia.org/wikipedia/commons/8/81/Chess_bdt60.png","png");
  
  public Bishop(int x,int y, boolean col,Board b){
    super(x,y,col,b);
    this.x = x;
    this.y = y;
    this.col = col;
    this.b = b;
  }
  
   public boolean canMove(int x1,int y1){
    if(Math.abs(x1 - this.x) == Math.abs(y1 - this.y)){
      
      if(b.taken[x1][y1] == null || b.taken[x1][y1].col != this.col){
        
        int signX = (x1-this.x)/Math.abs(x1-this.x);
        int signY = (y1-this.y)/Math.abs(y1-this.y);
      
        for(int i = 1;i < Math.abs(x1 - this.x);i++){
          if(b.taken[this.x + signX*i][this.y + signY*i] != null){
            new UiBooster().showInfoDialog("you cant jump over a piece");
            return false;
          }
        }
        return true;
      }
      else{
        new UiBooster().showInfoDialog("the square you are trying to move on is occupied");
        return false;
      }
    }
    else{
      new UiBooster().showInfoDialog("invalid bishop move");
      return false;
    }
  }
  
   public void makeMove (int x1,int y1){
    
    this.b.taken[x1][y1] = new Bishop(x1,y1,this.col,this.b);   
 
    this.b.taken[this.x][this.y] = null;

  }
  
   public void draw(){
    if(this.col)
      image(wBishop,100 + this.x*100,100+(7-this.y)*100,100,100);
    else
      image(bBishop,100 + this.x*100,100+(7-this.y)*100,100,100);
  }
  
   public String toString(){
    if(this.col)
      return "wBishop";
    return "bBishop";
  }
}
class Board {
  
  int x;
  int y;
  int Length = 800;
  int len = Length/8;
  
  Piece[][] taken = new Piece[8][8];
  
  
  public Board(int x , int y){
    this.x = x;
    this.y = y;
    
    
    
  }
  
   public String toString(){
    String ret = "";
    for(int i = 7; i >= 0; i--){
      for(int j = 0; j < this.taken[0].length; j++){
        if(this.taken[j][i]==null)
          ret+=" null ";
        else
          ret+=" "+this.taken[j][i].toString() +" ";
      }
      ret +="\n";
    }
    return ret;
  }
  
  public void draw(){
    strokeWeight(3);
    for(int i = 0;i<8;i++){
      
      //generating text
      textSize(80);
      fill(0);
      text(8-i+"", 25,175+i*100); 
      text(8-i+"", 925,175+i*100);
      text(PApplet.parseChar(65+i), 125+i*100,75);
      text(PApplet.parseChar(65+i), 125+i*100,975);
    
      //generating rows for board
      for(int j = 0;j<8;j++){
        if((i+j)%2==0){
          fill(0xFFFAE495);
        }
        else{
          fill(0xFFFC4FFA);
        }
        square(x+j*len,y+i*len,len);
      }
    }
      
  }
  
}
class King extends Piece{
  int x;
  int y;
  boolean col;               //true == white  false == black
  Board b;
  PImage wKing = loadImage("https://upload.wikimedia.org/wikipedia/commons/3/3b/Chess_klt60.png","png");
  PImage bKing = loadImage("https://upload.wikimedia.org/wikipedia/commons/e/e3/Chess_kdt60.png","png");
  
  public King(int x,int y, boolean col,Board b){
    super(x,y,col,b);
    this.x = x;
    this.y = y;
    this.col = col;
    this.b = b;
  }
  
   public boolean canMove(int x1,int y1){
    if((x1 - this.x <= 1 && x1 - this.x >= -1)&&(y1 - this.y <= 1 && y1 - this.y >= -1)){
      
      if(b.taken[x1][y1] == null || b.taken[x1][y1].col != this.col)
        return true;
      else{
        new UiBooster().showInfoDialog("the square you are trying to move on is occupied");
        return false;
      }
      
    }
    else{
      new UiBooster().showInfoDialog("invalid king move");
      return false;
    }
  }
  
   public void makeMove (int x1,int y1){
    
    this.b.taken[x1][y1] = new King(x1,y1,this.col,this.b);   
 
    this.b.taken[this.x][this.y] = null;

  }
  
   public void draw(){
    if(this.col)
      image(wKing,100 + this.x*100,100+(7-this.y)*100,100,100);
    else
      image(bKing,100 + this.x*100,100+(7-this.y)*100,100,100);
  }
  
   public String toString(){
    if(this.col)
      return "wKing";
    return "bKing";
  }
}
class Knight extends Piece{
  int x;
  int y;
  boolean col;               //true == white  false == black
  Board b;
  PImage wKnight = loadImage("https://upload.wikimedia.org/wikipedia/commons/2/28/Chess_nlt60.png","png");
  PImage bKnight = loadImage("https://upload.wikimedia.org/wikipedia/commons/f/f1/Chess_ndt60.png","png");
  
  public Knight(int x,int y, boolean col,Board b){
    super(x,y,col,b);
    this.x = x;
    this.y = y;
    this.col = col;
    this.b = b;
  }
  
   public boolean canMove(int x1,int y1){
    if((x1-this.x == 1 || x1-this.x == -1) && (y1 - this.y == 2 || y1 - this.y == -2) ||
    (x1-this.x == 2 || x1-this.x == -2) && (y1 - this.y == 1 || y1 - this.y == -1)){
      if(b.taken[x1][y1] == null || b.taken[x1][y1].col != this.col)
        return true;
      else{
        new UiBooster().showInfoDialog("the square you are trying to move on is occupied");
        return false;
      }
      
    }
    else{
      new UiBooster().showInfoDialog("invalid knight move");
      return false;
    }
  }
  
   public void makeMove (int x1,int y1){
    
    this.b.taken[x1][y1] = new Knight(x1,y1,this.col,this.b);   
 
    this.b.taken[this.x][this.y] = null;

  }
  
   public void draw(){
    if(this.col)
      image(wKnight,100 + this.x*100,100+(7-this.y)*100,100,100);
    else
      image(bKnight,100 + this.x*100,100+(7-this.y)*100,100,100);
  }
  
   public String toString(){
    if(this.col)
      return "wKnight";
    return "bKnight";
  }
}
class Pawn extends Piece{
  int x;
  int y;
  boolean col;               //true == white  false == black
  Board b;
  PImage wPawn = loadImage("https://upload.wikimedia.org/wikipedia/commons/0/04/Chess_plt60.png","png");
  PImage bPawn = loadImage("https://upload.wikimedia.org/wikipedia/commons/c/cd/Chess_pdt60.png","png");
  
  public Pawn(int x,int y, boolean col,Board b){
    super(x,y,col,b);
    this.x = x;
    this.y = y;
    this.col = col;
    this.b = b;
  }
  
  
  
   public boolean canMove(int x1,int y1){
    
    if(this.x == x1 &&(this.col && (this.y+1 == y1 || this.y==1 &&y1 == 3 && b.taken[x1][2]==null) ||       //is pawn possible move?(including two square move at the begining)
                      !this.col && (this.y-1 == y1 || this.y == 6 && y1 == 4 && b.taken[x1][5]==null) )){               
      
      if(b.taken[x1][y1] == null)                                            // place free?
        return true;
        
      else{
        new UiBooster().showInfoDialog("the square you are trying to move on is occupied");
        return false;
      }
      
    }
    
    else if((this.x+1==x1 || this.x-1==x1)  &&                                  //kill move?
    (this.y+1==y1 && this.col || this.y-1==y1 && !this.col)&& b.taken[x1][y1]!=null){                  
      
      if(b.taken[x1][y1].col != this.col)                                      // is enemy?
        return true;
      
      else{
        new UiBooster().showInfoDialog("you can't kill your piece");
        return false;
      }
    }
   
    else{
      new UiBooster().showInfoDialog("invalid pawn move");
      return false;
    }
   
  }
  
   public void makeMove (int x1,int y1){
    
    this.b.taken[x1][y1] = new Pawn(x1,y1,this.col,this.b);   
 
    this.b.taken[this.x][this.y] = null;

  }
  
   public void draw(){
    if(this.col)
      image(wPawn,100 + this.x*100,100+(7-this.y)*100,100,100);
    else
      image(bPawn,100 + this.x*100,100+(7-this.y)*100,100,100);
  }
  
   public String toString(){
    if(this.col)
      return "wPawn";
    return "bPawn";
  }
}
abstract class Piece {
  int x;
  int y;
  boolean col;
  Board b;
  
  public Piece(int x,int y, boolean col,Board b){
    this.x = x;
    this.y = y;
    this.col = col;
    this.b = b;
    this.b.taken[this.x][this.y] = this;
    
  }
 
   public abstract boolean canMove(int x1,int y1);
  
   public abstract void makeMove (int x1,int y1);
   
   public abstract void draw();

   public abstract String toString();
  
}
class Queen extends Piece{
  int x;
  int y;
  boolean col;               //true == white  false == black
  Board b;
  PImage wQueen = loadImage("https://upload.wikimedia.org/wikipedia/commons/4/49/Chess_qlt60.png","png");
  PImage bQueen = loadImage("https://upload.wikimedia.org/wikipedia/commons/a/af/Chess_qdt60.png","png");
  
  public Queen(int x,int y, boolean col,Board b){
    super(x,y,col,b);
    this.x = x;
    this.y = y;
    this.col = col;
    this.b = b;
  }
  
   public boolean canMove(int x1,int y1){
    if(Math.abs(x1 - this.x) == Math.abs(y1 - this.y)){
      
      if(b.taken[x1][y1] == null || b.taken[x1][y1].col != this.col){
        
        int signX = (x1-this.x)/Math.abs(x1-this.x);
        int signY = (y1-this.y)/Math.abs(y1-this.y);
      
        for(int i = 1;i < Math.abs(x1 - this.x);i++){
          if(b.taken[this.x + signX*i][this.y + signY*i] != null){
            new UiBooster().showInfoDialog("you cant jump over a piece");
            return false;
          }
        }
        return true;
      }
      else{
        new UiBooster().showInfoDialog("the square you are trying to move on is occupied");
        return false;
      }
    }
    
    else if(x1 == this.x || y1 == this.y){
      
      if(b.taken[x1][y1] == null || b.taken[x1][y1].col != this.col){
        
        for(int i = 1;i < Math.abs(x1-this.x) + Math.abs(y1-this.y);i++){
          
          if(y1 == this.y){
            int signX = (x1 - this.x)/Math.abs(x1-this.x);
            if(b.taken[this.x + signX*i][this.y ] != null){
              new UiBooster().showInfoDialog("you cant jump over a piece");
              return false;
            }
          }
          else{
            int signY = (y1 - this.y)/Math.abs(y1-this.y);
            if(b.taken[this.x][this.y + signY*i] != null){
              new UiBooster().showInfoDialog("you cant jump over a piece");
              return false;
            }
          }
        }
        return true;
      }
      else{
        new UiBooster().showInfoDialog("the square you are trying to move on is occupied");
        return false;
      }
    }
    else{
      new UiBooster().showInfoDialog("invalid queen move");
      return false;
    }
  }
  
   public void makeMove (int x1,int y1){
    
    this.b.taken[x1][y1] = new Queen(x1,y1,this.col,this.b);   
 
    this.b.taken[this.x][this.y] = null;

  }
  
   public void draw(){
    if(this.col)
      image(wQueen,100 + this.x*100,100+(7-this.y)*100,100,100);
    else
      image(bQueen,100 + this.x*100,100+(7-this.y)*100,100,100);
  }
  
   public String toString(){
    if(this.col)
      return "wQueen";
    return "bQueen";
  }
}
class Rook extends Piece{
  int x;
  int y;
  boolean col;               //true == white  false == black
  Board b;
  PImage wRook = loadImage("https://upload.wikimedia.org/wikipedia/commons/5/5c/Chess_rlt60.png","png");
  PImage bRook = loadImage("https://upload.wikimedia.org/wikipedia/commons/a/a0/Chess_rdt60.png","png");
  
  public Rook(int x,int y, boolean col,Board b){
    super(x,y,col,b);
    this.x = x;
    this.y = y;
    this.col = col;
    this.b = b;
  }
  
   public boolean canMove(int x1,int y1){
    if(x1 == this.x || y1 == this.y){
      
      if(b.taken[x1][y1] == null || b.taken[x1][y1].col != this.col){
        
        for(int i = 1;i < Math.abs(x1-this.x) + Math.abs(y1-this.y);i++){
          
          if(y1 == this.y){
            int signX = (x1 - this.x)/Math.abs(x1-this.x);
            if(b.taken[this.x + signX*i][this.y ] != null){
              new UiBooster().showInfoDialog("you cant jump over a piece");
              return false;
            }
          }
          else{
            int signY = (y1 - this.y)/Math.abs(y1-this.y);
            if(b.taken[this.x][this.y + signY*i] != null){
              new UiBooster().showInfoDialog("you cant jump over a piece");
              return false;
            }
          }
        }
        return true;
      }
      else{
        new UiBooster().showInfoDialog("the square you are trying to move on is occupied");
        return false;
      }
    }
    else{
      new UiBooster().showInfoDialog("invalid Rook move");
      return false;
    }
  }
  
   public void makeMove (int x1,int y1){
    
    this.b.taken[x1][y1] = new Rook(x1,y1,this.col,this.b);   
 
    this.b.taken[this.x][this.y] = null;

  }
  
   public void draw(){
    if(this.col)
      image(wRook,100 + this.x*100,100+(7-this.y)*100,100,100);
    else
      image(bRook,100 + this.x*100,100+(7-this.y)*100,100,100);
  }
  
   public String toString(){
    if(this.col)
      return "wRook";
    return "bRook";
  }
}


  public void settings() { size(1000, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Chess" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
